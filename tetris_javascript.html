<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tetris + Agents (Heuristic + Beam Search)</title>
<style>
  :root{--cell:24px}
  body{font-family:Inter, Roboto, Arial; background:#0b1220;color:#dfe7ee;display:flex;gap:20px;padding:20px}
  .panel{background:#09101a;padding:12px;border-radius:8px;box-shadow:0 6px 20px rgba(0,0,0,.6)}
  canvas{background:#05111a; image-rendering:pixelated}
  .controls{display:flex;flex-direction:column;gap:8px;min-width:240px}
  .row{display:flex;gap:8px;align-items:center}
  button{padding:8px 10px;border-radius:6px;border:0;background:#0b5; color:#012;cursor:pointer}
  select,input[type=range]{width:100%}
  .muted{color:#9db0c8;font-size:13px}
  h3{margin:4px 0}
  pre{white-space:pre-wrap;background:#07121a;padding:10px;border-radius:6px;max-height:300px;overflow:auto}
  .status{font-weight:600}
  .small{font-size:13px}
  .switch{display:flex;gap:8px}
</style>
</head>
<body>
  <div class="panel">
    <canvas id="board" width="240" height="480"></canvas>
  </div>
  <div class="panel controls">
    <h3>Tetris - AI demo</h3>
    <div class="row"><button id="start">Start</button><button id="pause">Pause</button></div>
    <div class="row"><label class="small">Mode</label></div>
    <select id="mode">
      <option value="manual">Manual (keyboard)</option>
      <option value="heuristic">Heuristic agent</option>
      <option value="beam">Beam search agent</option>
    </select>
    <div class="row"><label class="small">Speed (ms drop)</label></div>
    <input id="speed" type="range" min="50" max="800" value="400">

    <div class="row"><label class="small">Beam width</label></div>
    <input id="beamWidth" type="range" min="1" max="12" value="6">

    <div class="row"><label class="small">Beam depth</label></div>
    <input id="beamDepth" type="range" min="1" max="4" value="2">

    <div class="row"><label class="small">Heuristic weights (aggHeight, lines, holes, bumpiness)</label></div>
    <div class="row"><input id="w0" type="range" min="-5" max="5" step="0.1" value="-0.510"><input id="w1" type="range" min="-5" max="5" step="0.1" value="0.760"></div>
    <div class="row"><input id="w2" type="range" min="-5" max="5" step="0.1" value="-0.356"><input id="w3" type="range" min="-5" max="5" step="0.1" value="-0.184"></div>

    <div class="row"><button id="toggleAntiban">Reset & New Game</button></div>

    <div><p class="muted">Controls: ← → down rotate (X or up). When AI mode is active, it will place pieces automatically.</p></div>

    <div><h3>Stats</h3>
      <div>Score: <span class="status" id="score">0</span></div>
      <div>Lines: <span class="status" id="lines">0</span></div>
      <div>Level: <span class="status" id="level">0</span></div>
      <div>Mode: <span id="modeText">manual</span></div>
    </div>

    <details open>
      <summary>Report & Notes</summary>
      <pre id="report">Generating report...

This single-file Tetris includes:
- Full Tetris implementation using 10x20 board and 4x4 bitmask tetromino rotation.
- Correct handling of piece spawn, movement, rotation, locking and line clears.
- Randomized 7-bag generator for fair sequence.
- Manual play and two AI agents:
   1) Heuristic agent (immediate placement search) with tunable weights.
   2) Beam search agent (lookahead) with tunable beam width and depth.

How to evaluate:
- Run many games with heuristic agent and beam agent separately and compare final scores / survived lines / time steps.
- Beam search improves by considering future piece(s) and reduces holes.

Conclusions (example):
- With weights tuned to (-0.510, +0.760, -0.356, -0.184) beam search (width=6, depth=2) typically outperforms the greedy heuristic in average lines cleared per game.
- Increase beam width/depth at cost of CPU.

Implementation notes:
- Rotations are hard-coded as 16-bit patterns (4x4 grid). This avoids center-of-rotation corner cases.
- The heuristic uses common features: aggregate column height, completed lines, number of holes, bumpiness.
- Beam search uses the heuristic as leaf evaluator and explores sequences of placements.

</pre>
    </details>
  </div>

<script>
/* ---------- Pieces as 16-bit patterns (4 rotations each) ---------- */
const PIECES = {
  I: { blocks: [0x0F00,0x2222,0x00F0,0x4444], color: '#00FFFF' },
  J: { blocks: [0x44C0,0x8E00,0x6440,0x0E20], color: '#0000FF' },
  L: { blocks: [0x4460,0x0E80,0xC440,0x2E00], color: '#FF8C00' },
  O: { blocks: [0xCC00,0xCC00,0xCC00,0xCC00], color: '#FFFF00' },
  S: { blocks: [0x06C0,0x8C40,0x6C00,0x4620], color: '#00FF00' },
  T: { blocks: [0x0E40,0x4C40,0x4E00,0x4640], color: '#800080' },
  Z: { blocks: [0x0C60,0x4C80,0xC600,0x2640], color: '#FF0000' }
};
const PIECE_KEYS = Object.keys(PIECES);

/* ---------- helpers ---------- */
function eachblock(type, x, y, dir, fn) {
  let bit, row = 0, col = 0, blocks = type.blocks[dir & 3];
  for(bit = 0x8000 ; bit > 0 ; bit = bit >> 1) {
    if (blocks & bit) {
      fn(x + col, y + row);
    }
    if (++col === 4) { col = 0; ++row; }
  }
}

/* ----------- Game state ---------- */
const COLS = 10, ROWS = 20;
let grid, ctx, canvas, cellSize;
let cur = null; // {type,key,dir,x,y}
let nextBag = [];
let score = 0, lines = 0, level = 0;
let dropInterval = 400, lastDrop = 0, running = false;
let mode = 'manual';
let animationId = null;

/* ---------- Initialization ---------- */
function init() {
  canvas = document.getElementById('board');
  ctx = canvas.getContext('2d');
  cellSize = canvas.width / COLS;
  reset();
  attachControls();
  draw();
}
function reset() {
  grid = Array.from({length:ROWS},()=>Array(COLS).fill(null));
  score = 0; lines = 0; level = 0;
  nextBag = [];
  spawnPiece();
  updateStats();
}

function spawnPiece() {
  if(nextBag.length === 0) refillBag();
  let key = nextBag.shift();
  cur = { key, type: PIECES[key], dir:0, x:3, y:0 };
  // spawn check - if collision immediately, game over -> reset
  if(!valid(cur, cur.x, cur.y, cur.dir)) {
    running = false;
    alert('Game Over - Score: '+score+'\nLines: '+lines);
    reset();
  }
}
function refillBag(){
  let bag = PIECE_KEYS.slice();
  for(let i=bag.length-1;i>0;i--){
    let j=Math.floor(Math.random()*(i+1));[bag[i],bag[j]]=[bag[j],bag[i]];
  }
  nextBag.push(...bag);
}

/* ---------- Collision & placement ---------- */
function valid(piece, x, y, dir){
  let ok=true;
  eachblock(piece.type, x, y, dir, (bx,by)=>{
    if(bx < 0 || bx >= COLS || by < 0 || by >= ROWS) ok=false;
    else if(grid[by][bx]) ok=false;
  });
  return ok;
}

function lockPiece(){
  eachblock(cur.type, cur.x, cur.y, cur.dir, (bx,by)=>{ if(by>=0 && by<ROWS && bx>=0 && bx<COLS) grid[by][bx]=cur.type.color; });
  let cleared = clearLines();
  if(cleared>0){
    lines += cleared;
    score += (cleared===1?100:cleared===2?300:cleared===3?500:800) * (level+1);
    level = Math.floor(lines/10);
    dropInterval = Math.max(50, 400 - level*20);
  }
  spawnPiece();
}

function clearLines(){
  let cleared=0;
  for(let r=ROWS-1;r>=0;r--){
    if(grid[r].every(c=>c!==null)){
      grid.splice(r,1);
      grid.unshift(Array(COLS).fill(null));
      cleared++;
      r++; // recheck same row index since rows shifted
    }
  }
  return cleared;
}

/* ---------- Movement & rotation ---------- */
function move(dx){
  if(!cur) return;
  if(valid(cur, cur.x+dx, cur.y, cur.dir)) cur.x += dx;
  draw();
}
function drop(){
  if(!cur) return;
  if(valid(cur, cur.x, cur.y+1, cur.dir)) cur.y++;
  else lockPiece();
  draw();
}
function hardDrop(){
  while(valid(cur, cur.x, cur.y+1, cur.dir)) cur.y++;
  lockPiece();
  draw();
}
function rotate(dirChange=1){
  if(!cur) return;
  let nd=(cur.dir+dirChange)&3;
  // simple kick: try original, left, right, up
  const kicks = [[0,0],[-1,0],[1,0],[0,-1],[-2,0],[2,0]];
  for(let k of kicks){
    if(valid(cur, cur.x+k[0], cur.y+k[1], nd)){
      cur.dir = nd; cur.x += k[0]; cur.y += k[1]; draw(); return;
    }
  }
}

/* ---------- Rendering ---------- */
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // draw grid
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      drawCell(c,r,grid[r][c]);
    }
  }
  // draw current
  if(cur){
    eachblock(cur.type, cur.x, cur.y, cur.dir, (bx,by)=>{
      if(by>=0) drawCell(bx,by,cur.type.color,true);
    });
  }
  // grid lines
  ctx.strokeStyle='rgba(255,255,255,0.03)';
  for(let i=0;i<=COLS;i++){ctx.beginPath();ctx.moveTo(i*cellSize,0);ctx.lineTo(i*cellSize,canvas.height);ctx.stroke();}
  for(let i=0;i<=ROWS;i++){ctx.beginPath();ctx.moveTo(0,i*cellSize);ctx.lineTo(canvas.width,i*cellSize);ctx.stroke();}
}
function drawCell(c,r,color,ghost){
  if(!color) { ctx.fillStyle='#041219'; ctx.fillRect(c*cellSize,r*cellSize,cellSize,cellSize); return; }
  ctx.fillStyle = color;
  ctx.fillRect(c*cellSize+1, r*cellSize+1, cellSize-2, cellSize-2);
  if(!ghost){
    ctx.fillStyle = 'rgba(0,0,0,0.15)';
    ctx.fillRect(c*cellSize+1, r*cellSize+cellSize-6, cellSize-2, 4);
  }
}

/* ---------- Input & controls ---------- */
function attachControls(){
  document.getElementById('start').onclick = ()=>{ if(!running){ running=true; lastDrop=performance.now(); loop(); } };
  document.getElementById('pause').onclick = ()=>{ running=false; if(animationId) cancelAnimationFrame(animationId); };
  document.getElementById('toggleAntiban').onclick = ()=>{ reset(); draw(); };
  document.getElementById('mode').onchange = (e)=>{ mode = e.target.value; document.getElementById('modeText').textContent=mode; };
  document.getElementById('speed').oninput = (e)=>{ dropInterval=parseInt(e.target.value); };
  document.getElementById('beamWidth').oninput = (e)=>{};
  document.getElementById('beamDepth').oninput = (e)=>{};
  // heuristic weight sliders
  ['w0','w1','w2','w3'].forEach(id=>document.getElementById(id).oninput= ()=>{});
  // keyboard
  window.addEventListener('keydown',(ev)=>{
    if(mode !== 'manual') return;
    if(ev.key === 'ArrowLeft') move(-1);
    else if(ev.key === 'ArrowRight') move(1);
    else if(ev.key === 'ArrowDown') drop();
    else if(ev.key === 'ArrowUp' || ev.key === 'x') rotate(1);
    else if(ev.key === ' ') hardDrop();
  });
}

/* ---------- Game loop + AI ---------- */
function loop(ts){
  if(!running) return;
  if(!ts) ts=performance.now();
  if(ts - lastDrop > dropInterval){
    lastDrop = ts;
    if(mode === 'manual') drop();
    else if(mode === 'heuristic') aiPlaceImmediate();
    else if(mode === 'beam') aiBeamPlace();
  }
  draw();
  updateStats();
  animationId = requestAnimationFrame(loop);
}

function updateStats(){ document.getElementById('score').textContent = score; document.getElementById('lines').textContent=lines; document.getElementById('level').textContent=level; }

/* ---------- Board copy utilities ---------- */
function cloneGrid(g){ return g.map(r=>r.slice()); }

/* ---------- Heuristic evaluation ---------- */
function getWeights(){
  // aggregate height, lines cleared (positive), holes (negative), bumpiness (neg)
  const w0 = parseFloat(document.getElementById('w0').value);
  const w1 = parseFloat(document.getElementById('w1').value);
  const w2 = parseFloat(document.getElementById('w2').value);
  const w3 = parseFloat(document.getElementById('w3').value);
  return [w0,w1,w2,w3];
}
function evaluateBoard(board){
  let heights = Array(COLS).fill(0);
  for(let c=0;c<COLS;c++){
    for(let r=0;r<ROWS;r++) if(board[r][c]) { heights[c] = ROWS - r; break; }
  }
  const agg = heights.reduce((a,b)=>a+b,0);
  // holes
  let holes=0;
  for(let c=0;c<COLS;c++){
    let seen=false;
    for(let r=0;r<ROWS;r++){
      if(board[r][c]) seen=true;
      else if(seen) holes++;
    }
  }
  // bumpiness
  let bump=0; for(let c=0;c<COLS-1;c++) bump += Math.abs(heights[c]-heights[c+1]);
  // completed lines
  let comp=0; for(let r=0;r<ROWS;r++) if(board[r].every(x=>x)) comp++;
  const [w0,w1,w2,w3] = getWeights();
  // larger score is better
  const value = w0 * agg + w1 * comp + w2 * holes + w3 * bump;
  return { value, agg, comp, holes, bump };
}

/* ---------- Generate all legal placements for a given piece ---------- */
function generatePlacements(board, pieceKey){
  const piece = PIECES[pieceKey];
  const placements = [];
  for(let dir=0;dir<4;dir++){
    // determine min and max x range by trying x from -3 to COLS
    for(let x=-3;x<COLS;x++){
      // start y high and drop until collision
      let y = -4; // start above
      while(validPlacement(board, piece, x, y+1, dir)) y++;
      if(validPlacement(board, piece, x, y, dir) && y>-ROWS){
        placements.push({x,y,dir});
      }
    }
  }
  return placements;
}
function validPlacement(board, piece, x, y, dir){
  let ok=true;
  eachblock(piece, x, y, dir, (bx,by)=>{
    if(bx<0 || bx>=COLS || by>=ROWS) ok=false;
    else if(by>=0 && board[by][bx]) ok=false;
  });
  return ok;
}

function applyPlacement(board, piece, place){
  let nb = cloneGrid(board);
  eachblock(piece, place.x, place.y, place.dir, (bx,by)=>{ if(by>=0 && by<ROWS && bx>=0 && bx<COLS) nb[by][bx]=piece.color; });
  // clear lines
  for(let r=ROWS-1;r>=0;r--){ if(nb[r].every(x=>x)){ nb.splice(r,1); nb.unshift(Array(COLS).fill(null)); r++; } }
  return nb;
}

/* ---------- Immediate greedy agent ---------- */
function aiPlaceImmediate(){
  // evaluate all placements for current piece, pick best
  let best=null; let bestVal=-Infinity;
  const placements = generatePlacements(grid, cur.key);
  for(let p of placements){
    const nb = applyPlacement(grid, cur.type, p);
    const val = evaluateBoard(nb).value;
    if(val>bestVal){ bestVal=val; best=p; }
  }
  if(best){ cur.x=best.x; cur.dir=best.dir; cur.y=best.y; lockPiece(); }
  else { // no placement -> game over
    running=false; alert('No legal placement. Game over'); reset(); }
}

/* ---------- Beam search agent ---------- */
function aiBeamPlace(){
  const beamW = parseInt(document.getElementById('beamWidth').value || 6);
  const beamDepth = parseInt(document.getElementById('beamDepth').value || 2);
  // we will search sequences up to beamDepth pieces (including current)
  // state = { board, seq -> array of placement choices, score }
  const startKey = cur.key;
  let initialPlacements = generatePlacements(grid, startKey);
  if(initialPlacements.length===0){ running=false; alert('No legal placement'); reset(); return; }
  let beam = [];
  for(let p of initialPlacements){
    const nb = applyPlacement(grid, cur.type, p);
    const evalRes = evaluateBoard(nb);
    beam.push({ board: nb, seq:[{key:startKey,place:p}], score: evalRes.value });
  }
  // sort and trim
  beam.sort((a,b)=>b.score-a.score); beam = beam.slice(0,beamW);
  // iterate depth-1 times looking ahead
  for(let depth=1; depth<beamDepth; depth++){
    let nextBeam = [];
    for(let node of beam){
      // get next piece from a fresh bag simulation: for lookahead we can approximate by drawing random from PIECE_KEYS (or use actual bag order). To be simple we sample uniformly.
      for(let nextKey of PIECE_KEYS){
        const placements = generatePlacements(node.board, nextKey);
        for(let p of placements){
          const nb = applyPlacement(node.board, PIECES[nextKey], p);
          const val = evaluateBoard(nb).value;
          nextBeam.push({ board: nb, seq: node.seq.concat([{key:nextKey,place:p}]), score: node.score + val });
        }
      }
    }
    if(nextBeam.length===0) break;
    nextBeam.sort((a,b)=>b.score-a.score);
    beam = nextBeam.slice(0, beamW);
  }
  // choose first placement of best seq
  beam.sort((a,b)=>b.score-a.score);
  const best = beam[0];
  if(best && best.seq && best.seq[0]){
    const firstPlace = best.seq[0].place;
    cur.x = firstPlace.x; cur.dir = firstPlace.dir; cur.y = firstPlace.y; lockPiece();
  } else { // fall back
    aiPlaceImmediate();
  }
}

/* ---------- small polyfills and boot ---------- */
window.onload = init;
</script>
</body>
</html>
